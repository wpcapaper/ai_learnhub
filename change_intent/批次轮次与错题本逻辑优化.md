# 批次轮次与错题本逻辑优化 - 改动方案

## 需求概述

本次改动包含两个主要需求：

1. **批次轮次管理**：当前题库刷完后无法继续刷题，需要支持多轮刷题，并在课程页面显示当前轮次
2. **错题本逻辑修复**：错题本应基于同一道题的最近做错情况应用艾宾浩斯记忆曲线，历史错题未达到"掌握"程度不能离开错题本

---

## 需求 1：批次轮次管理

### 问题分析

**当前行为**：
- 用户开始批次时，`ReviewService.get_next_question()` 按以下优先级获取题目：
  1. 需要复习的错题（review_stage > 0 且 next_review_time <= now 且 is_correct = False）
  2. 用户没刷过的题（没有记录或 review_stage = 0）
- 当所有题目都答过后，查询返回空列表，抛出 "没有可用的题目" 错误
- 系统没有记录或跟踪"轮次"概念

**期望行为**：
- 当所有题目都刷完后，应该可以开始新的一轮
- 每次开始新轮时，所有题目重新变为可用状态（基于当前复习状态）
- 课程页面显示当前是第几轮

### 技术方案

#### 1. 数据库模型变更

**新增表：`UserCourseProgress`**

用于跟踪每个用户在每个课程上的进度和轮次信息。

```sql
CREATE TABLE user_course_progress (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    course_id VARCHAR(36) NOT NULL,
    current_round INT DEFAULT 1,          -- 当前轮次，从1开始
    total_rounds_completed INT DEFAULT 0,  -- 已完成轮次数
    started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, course_id),
    FOREIGN KEY(user_id) REFERENCES users(id),
    FOREIGN KEY(course_id) REFERENCES courses(id)
);
```

**修改：`QuizBatch` 表**

添加轮次字段以记录每个批次属于哪一轮。

```sql
ALTER TABLE quiz_batches ADD COLUMN round_number INT DEFAULT 1;
```

#### 2. 业务逻辑变更

**修改：`ReviewService.get_next_question()`**

新增参数 `allow_new_round`，当为 True 时，如果没有可用题目，允许开始新轮。

```python
@staticmethod
def get_next_question(
    db: Session,
    user_id: str,
    course_id: Optional[str] = None,
    batch_size: int = 10,
    allow_new_round: bool = True  # 新增参数
) -> List[Question]:
    """
    获取下一批复习题目

    优先级：
    1. 需要复习的错题
    2. 用户没刷过的题
    3. 如果 allow_new_round=True 且没有可用题，开始新轮
    """
    # ... 现有逻辑 ...

    # 如果没有题目且允许开始新轮
    if allow_new_round and len(result) == 0:
        # 开始新轮
        UserService.start_new_round(db, user_id, course_id)
        # 重新获取题目（此时所有题目重新基于当前复习状态变为可用）
        result = get_next_question(
            db, user_id, course_id, batch_size, allow_new_round=False
        )

    return result
```

**修改：`QuizService.start_batch()`**

在开始批次时关联轮次信息。

```python
@staticmethod
def start_batch(
    db: Session,
    user_id: str,
    mode: str = "practice",
    batch_size: int = 10,
    course_id: str = None
) -> QuizBatch:
    """
    开始一个新的刷题批次

    新增：记录当前轮次信息
    """
    # 获取或创建用户课程进度
    progress = UserService.get_or_create_progress(db, user_id, course_id)

    # 获取题目
    questions = ReviewService.get_next_question(
        db, user_id, course_id, batch_size, allow_new_round=True
    )

    if not questions:
        raise ValueError("没有可用的题目")

    # 创建批次（包含轮次信息）
    batch = QuizBatch(
        id=str(uuid.uuid4()),
        user_id=user_id,
        batch_size=len(questions),
        mode=mode,
        round_number=progress.current_round,  # ✅ 新增
        started_at=datetime.utcnow(),
        status="in_progress"
    )
    # ...
```

**新增：`UserService` 方法**

```python
@staticmethod
def get_or_create_progress(
    db: Session,
    user_id: str,
    course_id: str
) -> UserCourseProgress:
    """获取或创建用户课程进度记录"""
    progress = db.query(UserCourseProgress).filter(
        UserCourseProgress.user_id == user_id,
        UserCourseProgress.course_id == course_id
    ).first()

    if not progress:
        progress = UserCourseProgress(
            id=str(uuid.uuid4()),
            user_id=user_id,
            course_id=course_id,
            current_round=1,
            total_rounds_completed=0
        )
        db.add(progress)
        db.commit()
        db.refresh(progress)

    return progress

@staticmethod
def start_new_round(
    db: Session,
    user_id: str,
    course_id: str
) -> UserCourseProgress:
    """开始新轮"""
    progress = UserService.get_or_create_progress(db, user_id, course_id)

    # 更新轮次
    progress.current_round += 1
    progress.total_rounds_completed += 1
    progress.updated_at = datetime.utcnow()

    db.commit()
    db.refresh(progress)

    return progress
```

#### 3. API 变更

**修改：`GET /api/courses/` 响应**

增加轮次信息字段：

```typescript
interface Course {
    // ... 现有字段
    current_round?: number;      // 当前轮次
    total_rounds_completed?: number; // 已完成轮次数
}
```

**后端实现** (`courses.py`)：

```python
if user_id and c.course_type == 'exam':
    # ... 现有统计 ...

    # ✅ 新增：获取轮次信息
    progress = db.query(UserCourseProgress).filter(
        UserCourseProgress.user_id == user_id,
        UserCourseProgress.course_id == c.id
    ).first()

    if progress:
        course_data["current_round"] = progress.current_round
        course_data["total_rounds_completed"] = progress.total_rounds_completed
```

#### 4. 前端变更

**修改：`Course` 接口** (`lib/api.ts`)

```typescript
export interface Course {
    // ... 现有字段
    current_round?: number;
    total_rounds_completed?: number;
}
```

**修改：课程页面显示** (`courses/page.tsx`)

在课程卡片中显示轮次信息：

```tsx
{course.course_type === 'exam' && (
    <div className="text-sm text-gray-600 mb-4">
        <div className="flex justify-between mb-2">
            <span>题目总数: <strong>{course.total_questions || 0}</strong></span>
            <span>已刷题目: <strong>{course.answered_questions || 0}</strong></span>
        </div>
        <div className="text-center bg-blue-50 rounded-md py-2 px-4">
            <span className="text-blue-700 font-medium">
                第 {course.current_round || 1} 轮
                {course.total_rounds_completed > 0 && ` (已完成 ${course.total_rounds_completed} 轮)`}
            </span>
        </div>
    </div>
)}
```

---

## 需求 2：错题本逻辑修复

### 问题分析

**当前行为**：
- `get_wrong_questions()` 查询历史上曾经答错过且当前 `review_stage != 8` 的题目
- 艾宾浩斯曲线逻辑：
  - 答错：回到第 1 阶段
  - 答对：进入下一阶段
- 问题：同一个题目可能在历史上多次答错，但只跟踪最近一次错题状态

**期望行为**：
- 艾宾浩斯记忆曲线应该基于同一道题的**最近**做错情况
- 只要历史做错过且未达到"掌握"程度（review_stage != 8），题目就应该保留在错题本中
- 错题本的艾宾浩斯调度应该基于最近一次错误

### 技术方案

#### 1. 当前逻辑分析

**问题定位**：

1. `UserLearningRecord` 表存储的是**最新的**学习记录（每次答题都更新）
2. 没有保留历史错题记录
3. 艾宾浩斯曲线基于当前 `review_stage`，而不是基于最近的错题

**核心问题**：
- 当一道题从错变对后，`review_stage` 会递增
- 如果再次答错，`review_stage` 回到 1
- 但历史错题记录丢失，无法追踪"最近一次错误"的复习进度

#### 2. 解决方案

**方案选择**：

由于当前架构基于 `UserLearningRecord` 的最新记录，我们需要：

1. **保留错题历史记录**（可选，但更健壮）
2. **修改查询逻辑**，确保艾宾浩斯曲线基于最近的错题情况
3. **确保错题本中的题目不会因为"答对"而消失**，除非达到"掌握"状态

**推荐方案**：修改查询和更新逻辑

#### 3. 业务逻辑变更

**修改：`ReviewService.submit_answer()`**

确保错题本的复习进度基于最近的错题记录。

```python
@staticmethod
def submit_answer(
    db: Session,
    user_id: str,
    question_id: str,
    answer: str,
    is_correct: bool
) -> UserLearningRecord:
    """
    提交答案并更新学习记录（艾宾浩斯算法）

    修改说明：
    - 确保错题本的复习进度基于最近的错题情况
    - 即使答对，如果历史有错题记录且未掌握，仍需保留在错题本
    """
    # ... 获取现有记录 ...

    if record:
        # ✅ 新增：如果是错题本中的题目，即使答对也不能离开错题本
        # 除非达到"掌握"状态（review_stage == 8）
        if is_correct and record.review_stage < EbbinghausScheduler.MAX_STAGE:
            # 检查是否有历史错题记录
            has_wrong_history = db.query(UserLearningRecord).filter(
                UserLearningRecord.user_id == user_id,
                UserLearningRecord.question_id == question_id,
                UserLearningRecord.is_correct == False
            ).first()

            # 如果有错题历史，递增复习阶段
            if has_wrong_history:
                # 按照艾宾浩斯曲线递增
                next_stage = min(record.review_stage + 1, EbbinghausScheduler.MAX_STAGE)
                next_time = None if next_stage == EbbinghausScheduler.MAX_STAGE else \
                           datetime.utcnow() + timedelta(minutes=EbbinghausScheduler.REVIEW_INTERVALS[next_stage])

                # ✅ 重要：更新记录，但不改变 is_correct 为 True
                # 这样题目仍保留在错题本中，直到掌握
                record.review_stage = next_stage
                record.next_review_time = next_time
                record.answered_at = datetime.utcnow()

                db.commit()
                db.refresh(record)
                return record

        # 正常更新逻辑（非错题本题目或已掌握）
        current_stage = record.review_stage
        next_stage, next_time = EbbinghausScheduler.calculate_next_review(
            current_stage, is_correct
        )

        record.is_correct = is_correct
        record.answer = answer
        record.answered_at = datetime.utcnow()
        record.review_stage = next_stage
        record.next_review_time = next_time
    else:
        # 新记录
        next_stage, next_time = EbbinghausScheduler.calculate_next_review(0, is_correct)
        record = UserLearningRecord(
            id=str(uuid.uuid4()),
            user_id=user_id,
            question_id=question_id,
            is_correct=is_correct,
            answer=answer,
            answered_at=datetime.utcnow(),
            review_stage=next_stage,
            next_review_time=next_time
        )
        db.add(record)

    db.commit()
    db.refresh(record)
    return record
```

**问题**：上述方案会破坏当前的 `is_correct` 逻辑。

**修正方案**：保持现有逻辑，但修改错题本查询逻辑。

**修改：`ReviewService.get_wrong_questions()`**

确保查询逻辑正确识别错题本题目。

```python
@staticmethod
def get_wrong_questions(
    db: Session,
    user_id: str,
    course_id: Optional[str] = None,
    limit: int = 100
) -> dict:
    """
    获取用户的错题列表

    错题定义（修正版）：
    - 历史上曾经答错过（存在 is_correct == False 的记录）
    - 且当前未达到已掌握状态（review_stage != 8）

    关键修改：
    - 使用子查询确保获取的是"最新"答题记录
    - 检查历史是否有错题
    - 确保艾宾浩斯曲线基于最近的错题情况
    """
    # ... 现有逻辑保持不变 ...

    # 主查询已经正确实现了：
    # 1. 找出最新答题记录
    # 2. 检查历史是否有错题记录
    # 3. 筛选未达到掌握状态的题目

    # 因此，当前实现已经满足需求
    # 唯一需要确认的是：错题本的复习调度是否正确

    return {
        "questions": questions,
        "wrong_times": wrong_times
    }
```

**关键问题**：错题本的复习调度

需要确保错题本中的题目按照艾宾浩斯曲线进行复习。

**修改：`ReviewService.get_next_question()`**

确保错题本中的题目按照正确的优先级进行复习。

```python
@staticmethod
def get_next_question(
    db: Session,
    user_id: str,
    course_id: Optional[str] = None,
    batch_size: int = 10,
    allow_new_round: bool = True
) -> List[Question]:
    """
    获取下一批复习题目

    优先级（修正版）：
    1. 需要复习的错题（review_stage > 0 且 next_review_time <= now）
       - 注意：这里包含历史上答错过但当前可能答对的题目
    2. 用户没刷过的题（没有记录或 review_stage = 0）
    3. 如果 allow_new_round=True 且没有可用题，开始新轮
    """
    now = utcnow_with_tz()

    # ✅ 修正：1. 优先：需要复习的错题（包含历史错题）
    wrong_due_query = (
        db.query(Question)
        .join(UserLearningRecord, and_(UserLearningRecord.question_id == Question.id))
        .filter(
            UserLearningRecord.user_id == user_id,
            UserLearningRecord.review_stage > 0,           # ✅ 去掉 is_correct == False 条件
            UserLearningRecord.next_review_time <= now,     # ✅ 复习时间到了
            UserLearningRecord.review_stage < EbbinghausScheduler.MAX_STAGE,  # ✅ 未掌握
            Question.is_deleted == False
        )
    )

    # 确保只选择历史上答错过或正在复习的题目
    wrong_due_query = wrong_due_query.filter(
        exists().where(
            and_(
                UserLearningRecord.question_id == Question.id,
                UserLearningRecord.user_id == user_id,
                UserLearningRecord.is_correct == False  # ✅ 历史上有错题记录
            )
        )
    )

    if course_id:
        wrong_due_query = wrong_due_query.filter(Question.course_id == course_id)

    wrong_due_questions = wrong_due_query.limit(batch_size).all()

    if len(wrong_due_questions) >= batch_size:
        return wrong_due_questions[:batch_size]

    # ... 剩余逻辑保持不变 ...
```

**问题**：上述查询过于复杂，且可能有性能问题。

**最终方案**：

经过分析，当前的 `get_wrong_questions()` 逻辑已经正确实现了需求：

1. 找出历史上答错过且未掌握的题目 ✓
2. 返回最近的错题时间 ✓

但问题在于**错题本的复习调度**。当前 `get_next_question()` 优先筛选的是：
- `is_correct == False` 的题目

这导致错题本中已经答对的题目不会出现在复习队列中。

**解决方案**：修改复习调度逻辑，去除 `is_correct == False` 条件。

**修改：`ReviewService.get_next_question()`**

```python
@staticmethod
def get_next_question(
    db: Session,
    user_id: str,
    course_id: Optional[str] = None,
    batch_size: int = 10,
    allow_new_round: bool = True
) -> List[Question]:
    """获取下一批复习题目"""
    now = utcnow_with_tz()

    # ✅ 1. 优先：需要复习的题目（基于艾宾浩斯曲线）
    # 包含：错题本题目（历史上答错过）和新题
    due_query = (
        db.query(Question)
        .join(UserLearningRecord, and_(UserLearningRecord.question_id == Question.id))
        .filter(
            UserLearningRecord.user_id == user_id,
            UserLearningRecord.next_review_time <= now,      # 复习时间到了
            UserLearningRecord.review_stage < EbbinghausScheduler.MAX_STAGE,  # 未掌握
            Question.is_deleted == False
        )
    )

    if course_id:
        due_query = due_query.filter(Question.course_id == course_id)

    due_questions = due_query.limit(batch_size).all()

    if len(due_questions) >= batch_size:
        # ✅ 优先返回错题本中的题目
        # 排序：最近错题优先
        due_questions.sort(key=lambda q: (
            # 历史是否有错题
            db.query(UserLearningRecord).filter(
                UserLearningRecord.user_id == user_id,
                UserLearningRecord.question_id == q.id,
                UserLearningRecord.is_correct == False
            ).first() is not None,
            # 复习阶段（越低越优先）
            db.query(UserLearningRecord).filter(
                UserLearningRecord.user_id == user_id,
                UserLearningRecord.question_id == q.id
            ).first().review_stage
        ))
        return due_questions[:batch_size]

    # 2. 次优先：用户没刷过的题
    # ... 现有逻辑 ...

    # 3. 新轮逻辑
    # ... 现有逻辑 ...
```

**简化方案**：

实际上，问题的根源在于：**当前的 `get_next_question()` 只筛选 `is_correct == False` 的题目作为"需要复习的错题"**。

这导致错题本中已经答对的题目不会进入复习队列。

**正确的做法**：

保持当前的 `get_wrong_questions()` 逻辑不变（它已经正确识别错题本题目）。
只需要在 `get_next_question()` 中，确保错题本题目按照艾宾浩斯曲线进入复习队列。

**最终实现**：

```python
@staticmethod
def get_next_question(
    db: Session,
    user_id: str,
    course_id: Optional[str] = None,
    batch_size: int = 10,
    allow_new_round: bool = True
) -> List[Question]:
    """获取下一批复习题目"""
    now = utcnow_with_tz()

    # 1. 优先：需要复习的题目（按照艾宾浩斯曲线）
    # 包括：错题本题目（历史上答错过）和新题
    due_query = (
        db.query(Question)
        .join(UserLearningRecord, and_(UserLearningRecord.question_id == Question.id))
        .filter(
            UserLearningRecord.user_id == user_id,
            UserLearningRecord.next_review_time <= now,      # 复习时间到了
            UserLearningRecord.review_stage < EbbinghausScheduler.MAX_STAGE,  # 未掌握
            Question.is_deleted == False
        )
    )

    if course_id:
        due_query = due_query.filter(Question.course_id == course_id)

    due_questions = due_query.order_by(
        UserLearningRecord.next_review_time  # 按复习时间排序
    ).limit(batch_size).all()

    if len(due_questions) >= batch_size:
        # 优先返回错题本中的题目（历史上答错过）
        wrong_due_questions = [
            q for q in due_questions
            if db.query(UserLearningRecord).filter(
                UserLearningRecord.user_id == user_id,
                UserLearningRecord.question_id == q.id,
                UserLearningRecord.is_correct == False
            ).first() is not None
        ]

        # 如果错题本题目足够，只返回错题
        if len(wrong_due_questions) >= batch_size:
            return wrong_due_questions[:batch_size]

        # 否则，返回所有到期的题目
        return due_questions[:batch_size]

    # 2. 次优先：用户没刷过的题
    remaining_slots = batch_size - len(due_questions)

    new_questions_query = (
        db.query(Question)
        .outerjoin(
            UserLearningRecord,
            and_(
                UserLearningRecord.user_id == user_id,
                UserLearningRecord.question_id == Question.id
            )
        )
        .filter(
            or_(
                UserLearningRecord.id == None,
                and_(
                    UserLearningRecord.review_stage == 0,
                    UserLearningRecord.next_review_time == None
                )
            ),
            Question.is_deleted == False
        )
    )

    if course_id:
        new_questions_query = new_questions_query.filter(Question.course_id == course_id)

    new_questions = new_questions_query.limit(remaining_slots).all()
    result = due_questions + new_questions

    # 3. 新轮逻辑
    if allow_new_round and len(result) == 0:
        progress = UserService.get_or_create_progress(db, user_id, course_id)
        UserService.start_new_round(db, user_id, course_id)

        # 重新获取题目（不允许多次递归）
        result = ReviewService.get_next_question(
            db, user_id, course_id, batch_size, allow_new_round=False
        )

    return result[:batch_size]
```

---

## 总结

### 需求 1：批次轮次管理

**改动点**：
1. 新增 `UserCourseProgress` 模型
2. 修改 `QuizBatch` 模型，添加 `round_number` 字段
3. 修改 `ReviewService.get_next_question()`，支持开始新轮
4. 修改 `QuizService.start_batch()`，记录轮次信息
5. 新增 `UserService` 方法：`get_or_create_progress()`, `start_new_round()`
6. 修改 `CourseService.get_courses()`，返回轮次信息
7. 修改前端 `Course` 接口和课程页面，显示轮次信息

### 需求 2：错题本逻辑修复

**改动点**：
1. 修改 `ReviewService.get_next_question()`，确保错题本题目按照艾宾浩斯曲线进入复习队列
2. 保持 `get_wrong_questions()` 逻辑不变（已正确实现）
3. 确保错题本题目不会因为"答对"而消失，除非达到"掌握"状态

### 关键要点

1. **轮次管理**：
   - 每个用户在每个课程上有独立的轮次追踪
   - 当所有题目都刷完后，自动开始新轮
   - 课程页面显示当前轮次和已完成轮次数

2. **错题本逻辑**：
   - 艾宾浩斯曲线基于同一道题的最近做错情况
   - 错题本中的题目按照艾宾浩斯曲线进行复习
   - 题目只有在达到"掌握"状态（review_stage == 8）后才会离开错题本

---

## 风险评估

1. **数据一致性**：
   - 需要确保 `UserCourseProgress` 和 `QuizBatch.round_number` 的数据一致
   - 建议：在数据库层添加外键约束

2. **性能影响**：
   - `get_next_question()` 的查询可能变复杂
   - 建议：添加适当的索引

3. **向后兼容**：
   - 现有数据需要迁移
   - 建议：编写数据库迁移脚本
