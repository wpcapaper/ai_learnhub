# 批次刷题题目推荐逻辑修复

**日期**: 2026-01-22
**问题描述**: 题目刷完后开启批次报错"没有可用的题目"

---

## 问题场景

### 用户描述
1. 当前题目刷完后，开启批次报错"没有可用的题目"
2. 可能和之前的刷题记录改造有关
3. 开启批次的题目应该：
   - 首先推荐艾宾浩斯复习阶段的题目
   - 然后是该轮次没刷过的题
4. 展示问题：第1批次的课程会显示"第1批0"，这个0很奇怪

---

## 问题根源分析

### 问题1："没有可用的题目"报错

#### 代码位置
- **报错位置**: `src/backend/app/services/quiz_service.py:56`
- **触发条件**: `ReviewService.get_next_question(allow_new_round=True)` 返回空列表

#### 现有逻辑分析

**文件**: `src/backend/app/services/review_service.py` (第108-212行)

当前题目获取逻辑：

```python
def get_next_question(db, user_id, course_id, batch_size, allow_new_round):
    # 1. 优先：需要复习的题目（按照艾宾浩斯曲线）
    due_query = db.query(Question).join(UserLearningRecord).filter(
        UserLearningRecord.user_id == user_id,
        UserLearningRecord.next_review_time <= now,      # 复习时间到了
        UserLearningRecord.review_stage < EbbinghausScheduler.MAX_STAGE,  # 未掌握（review_stage < 8）
        UserLearningRecord.review_stage > 0,           # 有复习记录（排除新题）
        UserLearningRecord.completed_in_current_round == False,  # 当前轮次未刷过
        Question.is_deleted == False
    )

    due_questions = due_query.order_by(UserLearningRecord.next_review_time).limit(batch_size).all()

    if len(due_questions) >= batch_size:
        return due_questions[:batch_size]

    # 2. 次优先：用户没刷过的题（新题）
    remaining_slots = batch_size - len(due_questions)

    new_questions_query = db.query(Question).outerjoin(UserLearningRecord).filter(
        or_(
            UserLearningRecord.id == None,  # 没有任何学习记录
            and_(
                UserLearningRecord.review_stage == 0,  # 复习阶段为0，表示新题
                UserLearningRecord.next_review_time == None  # 且没有安排复习时间
            )
        ),
        Question.is_deleted == False
    )

    new_questions = new_questions_query.limit(remaining_slots).all()
    result = due_questions + new_questions

    # 3. 新轮逻辑：如果没有可用题目，允许开始新轮
    if allow_new_round and len(result) == 0 and course_id:
        UserService.start_new_round(db, user_id, course_id)
        result = ReviewService.get_next_question(db, user_id, course_id, batch_size, allow_new_round=False)

    return result[:batch_size]
```

#### 问题分析

**场景**：用户完成第一轮所有题目后，开启第二轮

1. **第一优先级 - 艾宾浩斯复习题**：
   - 所有题目在第一轮已答过，`completed_in_current_round = True`
   - 查询条件 `completed_in_current_round == False` 导致所有题目被过滤
   - `due_questions` 返回空列表

2. **第二优先级 - 新题**：
   - 所有题目都有学习记录（`UserLearningRecord.id` 不为空）
   - 查询条件 `review_stage == 0 AND next_review_time == None` 要求必须是新题
   - 但第一轮答过的题目 `review_stage` 可能在 1-8 之间
   - `new_questions` 返回空列表

3. **新轮逻辑触发**：
   - `allow_new_round=True` 且 `len(result) == 0`
   - 调用 `UserService.start_new_round()`：
     - `current_round += 1`
     - `total_rounds_completed += 1`
     - 将所有题目的 `completed_in_current_round` 重置为 `False`

4. **递归查询**：
   - 再次调用 `get_next_question(allow_new_round=False)`
   - 仍然无法获取题目（理由同上）

**核心问题**：
- 新轮逻辑重置了 `completed_in_current_round`，但查询逻辑仍然只关注"艾宾浩斯复习题"和"新题"
- 已掌握的题目（`review_stage == 8`）被完全忽略
- 第二轮应该可以刷已掌握的题目，但当前查询逻辑没有考虑这种情况

#### 期望的业务逻辑

根据用户描述，题目推荐应该是：

1. **优先**：艾宾浩斯复习阶段的题目（`review_stage` 在 1-7 之间，复习时间到了）
2. **次优先**：当前轮次没刷过的题目（包括已掌握但未在新轮刷过的题目）
3. **再次**：新题（完全没有学习记录的题目）

---

### 问题2："第1批0"显示问题

#### 代码位置
- **前端显示**: `src/frontend/app/courses/page.tsx` (第168-173行)

```tsx
<div className="text-center bg-blue-50 rounded-md py-2 px-4">
  <span className="text-blue-700 font-medium">
    第 {course.current_round || 1} 轮
    {course.total_rounds_completed && course.total_rounds_completed > 0 && ` (已完成 ${course.total_rounds_completed} 轮)`}
  </span>
</div>
```

#### 分析

显示逻辑：
- 显示当前轮次：`第 {current_round || 1} 轮`
- 如果 `total_rounds_completed > 0`，才显示 `(已完成 X 轮)`

初始状态：
- `current_round = 1`
- `total_rounds_completed = 0`

所以显示应该是：`第 1 轮`（不会显示 "(已完成 0 轮)"）

**结论**：前端显示逻辑是正确的。用户可能看到的是"第1轮"，而不是"第1批0"。

---

## 解决方案

### 方案设计

#### 核心原则
艾宾浩斯复习逻辑和轮次管理逻辑完全独立，不相互耦合：
- **艾宾浩斯复习逻辑**：只看 `review_stage` 和 `next_review_time`，判断哪些题目需要复习
- **轮次管理逻辑**：只看 `completed_in_current_round`，判断哪些题目在当前轮次刷过

#### 修改题目获取逻辑

**优先级调整**：

1. **优先**：艾宾浩斯复习阶段的题目
   - 条件：`review_stage > 0 AND review_stage < 8 AND next_review_time <= now`
   - **关键修复**：移除了 `completed_in_current_round` 条件，艾宾浩斯复习逻辑与轮次管理解耦

2. **次优先**：当前轮次未刷过的题目（与复习题去重）
   - 条件：`completed_in_current_round == False`
   - **关键业务逻辑**：在新轮次中，所有题目都应该可以重新刷题（包括已掌握的）
   - **去重逻辑**：排除掉已经返回的复习题，避免重复

3. **再次**：新题
   - 条件：`review_stage == 0 AND next_review_time == None`

#### 伪代码

```python
def get_next_question(db, user_id, course_id, batch_size, allow_new_round):
    # 1. 优先：艾宾浩斯复习阶段的题目（只看艾宾浩斯复习条件）
    due_questions = db.query(Question).join(UserLearningRecord).filter(
        UserLearningRecord.user_id == user_id,
        UserLearningRecord.next_review_time <= now,
        UserLearningRecord.review_stage > 0,
        UserLearningRecord.review_stage < EbbinghausScheduler.MAX_STAGE,
        Question.is_deleted == False
        # 不包括 completed_in_current_round，艾宾浩斯复习逻辑与轮次管理解耦
    ).order_by(UserLearningRecord.next_review_time).limit(batch_size).all()

    if len(due_questions) >= batch_size:
        return due_questions[:batch_size]

    # 2. 次优先：当前轮次未刷过的题目（只看轮次管理条件）
    remaining_slots = batch_size - len(due_questions)

    # 获取已获取的复习题ID列表，用于去重
    due_question_ids = [q.id for q in due_questions]

    not_completed_query = db.query(Question).join(UserLearningRecord).filter(
        UserLearningRecord.user_id == user_id,
        UserLearningRecord.completed_in_current_round == False,  # 当前轮次未刷过
        Question.is_deleted == False
    )

    # 与复习题去重，避免重复返回同一道题
    if due_question_ids:
        not_completed_query = not_completed_query.filter(~Question.id.in_(due_question_ids))

    not_completed_questions = not_completed_query.limit(remaining_slots).all()
    result = due_questions + not_completed_questions

    if len(result) >= batch_size:
        return result[:batch_size]

    # 3. 再次：新题
    remaining_slots = batch_size - len(result)

    new_questions = db.query(Question).outerjoin(UserLearningRecord).filter(
        or_(
            UserLearningRecord.id == None,
            and_(
                UserLearningRecord.review_stage == 0,
                UserLearningRecord.next_review_time == None
            )
        ),
        Question.is_deleted == False
    ).limit(remaining_slots).all()

    result = result + new_questions

    # 4. 新轮逻辑
    if allow_new_round and len(result) == 0 and course_id:
        UserService.start_new_round(db, user_id, course_id)
        result = ReviewService.get_next_question(db, user_id, course_id, batch_size, allow_new_round=False)

    return result[:batch_size]
```

---

## 影响范围

### 修改的文件
1. `src/backend/app/services/review_service.py` - 题目获取逻辑

### 需要验证的场景
1. 新用户第一次刷题（应该返回新题）
2. 第一轮刷完后开启第二轮（应该返回已掌握的题目）
3. 有艾宾浩斯复习题时（应该优先返回复习题）
4. 所有题目都刷完后开启新轮（应该可以正常开启）

---

## 总结

### 核心问题
题目推荐逻辑没有考虑"已掌握题目在新轮次可以重新刷题"的需求

### 解决方案
在题目获取逻辑中增加"已掌握但未在新轮次刷过的题目"作为第二优先级

### 关键业务逻辑
- 艾宾浩斯复习算法独立于轮次管理
- 轮次切换后，所有题目都应该可以在新轮次重新刷题
- 优先级：复习题 > 已掌握未刷题 > 新题
