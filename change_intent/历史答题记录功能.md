# 历史答题记录功能 - 改动方案

## 需求概述

### 当前问题

**现有数据结构问题**：
- `UserLearningRecord` 表是题目维度的，每个用户-题目对只有一条记录
- 当用户重新刷题时，原有的 `is_correct` 字段会被更新
- 导致历史错题记录丢失，无法追踪"这道题曾经做错过"

**具体影响**：
1. 无法满足"历史做错的题需要出现在错题本中"的需求
2. 错题本只能显示当前 `is_correct == false` 的题目
3. 无法支持题目维度的历史数据分析
4. 不利于后续扩展学习分析功能

### 需求目标

1. **新增历史答题记录表**：记录用户每次的答题情况，保留完整历史
2. **评估字段冗余**：新增历史记录后，评估原表哪些字段可以废弃
3. **错题本优化**：同一道题错多次时，错题本只提取最近一次做错的情况
4. **逻辑解耦**：错题推荐逻辑只看 `review_stage`，与 `is_correct` 解耦
5. **轮次保护**：轮次字段不受此次变更影响

---

## 技术方案

### 1. 数据库模型变更

#### 新增表：`UserAnswerHistory`

```sql
CREATE TABLE user_answer_history (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    question_id VARCHAR(36) NOT NULL,
    answer VARCHAR(10) NOT NULL,
    is_correct BOOLEAN NOT NULL,
    answered_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    review_stage INT NOT NULL,  -- 答题时的复习阶段
    batch_id VARCHAR(36),  -- 关联的批次ID（可选）
    FOREIGN KEY(user_id) REFERENCES users(id),
    FOREIGN KEY(question_id) REFERENCES questions(id),
    INDEX idx_user_question (user_id, question_id),
    INDEX idx_answered_at (answered_at),
    INDEX idx_user_id (user_id),
    INDEX idx_question_id (question_id)
);
```

**字段说明**：
- `id`: 主键
- `user_id`: 用户ID
- `question_id`: 题目ID
- `answer`: 用户答案
- `is_correct`: 是否正确（固定不变，记录当时的答案状态）
- `answered_at`: 答题时间
- `review_stage`: 答题时的复习阶段
- `batch_id`: 关联的批次ID（用于追溯属于哪个批次）

**设计原则**：
- 每次答题都创建新记录，**从不更新**
- `is_correct` 字段固定不变，记录当时的状态
- 通过索引支持高效查询

#### 评估：`UserLearningRecord` 字段冗余分析

新增历史记录表后，`UserLearningRecord` 中的以下字段可以废弃：

| 字段 | 当前用途 | 是否废弃 | 原因 |
|------|---------|---------|------|
| `is_correct` | 记录当前答题对错 | **废弃** | 历史记录表已有，当前表只需保留复习状态 |
| `answer` | 记录用户答案 | **废弃** | 历史记录表已有 |
| `answered_at` | 记录答题时间 | **废弃** | 历史记录表已有 |

**保留的字段**（用于艾宾浩斯算法）：
- `review_stage`: 当前复习阶段（必须保留）
- `next_review_time`: 下次复习时间（必须保留）
- `completed_in_current_round`: 当前轮次是否刷过（必须保留，轮次管理依赖）

**迁移策略**：
1. 保留 `UserLearningRecord` 表，用于存储艾宾浩斯状态
2. 废弃字段标记为 `is_correct`、`answer`、`answered_at`（不删除，但不再使用）
3. 新功能使用 `UserAnswerHistory` 表

---

### 2. 业务逻辑变更

#### 修改：`ReviewService.submit_answer()`

**变更说明**：
1. 创建新的历史记录（`UserAnswerHistory`）
2. 只更新 `UserLearningRecord` 的复习状态字段
3. 不再更新 `is_correct`、`answer`、`answered_at` 字段

```python
@staticmethod
def submit_answer(
    db: Session,
    user_id: str,
    question_id: str,
    answer: str,
    is_correct: bool,
    batch_id: Optional[str] = None  # 新增参数
) -> UserLearningRecord:
    """
    提交答案并更新学习记录（艾宾浩斯算法）

    变更说明：
    - 创建历史答题记录（UserAnswerHistory），保留完整历史
    - UserLearningRecord 只存储复习状态，不再存储 answer 和 is_correct
    - 错题推荐逻辑与 is_correct 解耦，只依赖 review_stage
    """
    import uuid

    # 1. 创建历史答题记录（每次答题都创建新记录，永不更新）
    record = db.query(UserLearningRecord).filter(
        UserLearningRecord.user_id == user_id,
        UserLearningRecord.question_id == question_id
    ).first()

    if record:
        current_stage = record.review_stage
    else:
        current_stage = 0

    next_stage, next_time = EbbinghausScheduler.calculate_next_review(
        current_stage, is_correct
    )

    # ✅ 创建历史记录（新表）
    from app.models import UserAnswerHistory
    history = UserAnswerHistory(
        id=str(uuid.uuid4()),
        user_id=user_id,
        question_id=question_id,
        answer=answer,
        is_correct=is_correct,
        answered_at=datetime.utcnow(),
        review_stage=current_stage,  # 记录答题时的复习阶段
        batch_id=batch_id  # 关联批次（可选）
    )
    db.add(history)

    # 2. 更新 UserLearningRecord（只更新复习状态字段）
    if record:
        # ✅ 不再更新 is_correct、answer、answered_at
        record.review_stage = next_stage
        record.next_review_time = next_time
        record.completed_in_current_round = True
    else:
        # 新记录（只存储复习状态）
        record = UserLearningRecord(
            id=str(uuid.uuid4()),
            user_id=user_id,
            question_id=question_id,
            is_correct=True,  # 默认值，不再使用
            answer="",  # 默认值，不再使用
            answered_at=datetime.utcnow(),  # 默认值，不再使用
            review_stage=next_stage,
            next_review_time=next_time,
            completed_in_current_round=True
        )
        db.add(record)

    db.commit()
    db.refresh(record)
    return record
```

**关键业务逻辑**（中文注释）：
```python
# 创建历史答题记录，保留每次答题的完整信息
# 这确保了错题本可以追踪"历史上做错过"的题目
history = UserAnswerHistory(
    ...
)

# 更新学习记录，只存储艾宾浩斯复习状态
# is_correct、answer、answered_at 字段不再使用，避免冗余
record.review_stage = next_stage
record.next_review_time = next_time
```

#### 修改：`ReviewService.get_wrong_questions()`

**变更说明**：
1. 使用 `UserAnswerHistory` 表查询最近的做错时间
2. 确保错题本显示历史上曾经答错过且未掌握的题目
3. 同一题错多次时，取最近一次做错的时间

```python
@staticmethod
def get_wrong_questions(
    db: Session,
    user_id: str,
    course_id: Optional[str] = None,
    limit: int = 100
) -> dict:
    """
    获取用户的错题列表

    错题定义（修改版）：
    - 历史上曾经答错过（UserAnswerHistory 中存在 is_correct == False 的记录）
    - 且当前未达到已掌握状态（review_stage != 8）

    变更说明：
    - 使用 UserAnswerHistory 表查询最近的做错时间
    - 错题推荐逻辑与 is_correct 解耦，只依赖 review_stage
    """
    from app.models import UserAnswerHistory

    # 子查询：找出每个题目最近一次答错的记录
    # 关键业务逻辑：确保错题本只提取最近一次做错的情况
    latest_wrong_subquery = (
        db.query(
            UserAnswerHistory.question_id.label('q_id'),
            func.max(UserAnswerHistory.answered_at).label('wrong_time')
        )
        .filter(
            UserAnswerHistory.user_id == user_id,
            UserAnswerHistory.is_correct == False  # 只查询错题记录
        )
        .group_by(UserAnswerHistory.question_id)
        .subquery()
    )

    # 主查询：筛选出曾经答错过、且未达到已掌握状态的题目
    # 关键业务逻辑：错题本只显示历史错题且未掌握的题目
    # 即使中途答对，只要未掌握（review_stage != 8），仍在错题本中
    query = (
        db.query(Question, latest_wrong_subquery.c.wrong_time.label('wrong_time'))
        .join(
            UserLearningRecord,
            Question.id == UserLearningRecord.question_id
        )
        .join(
            latest_wrong_subquery,
            Question.id == latest_wrong_subquery.c.q_id
        )
        .filter(
            UserLearningRecord.user_id == user_id,
            UserLearningRecord.review_stage != EbbinghausScheduler.MAX_STAGE,  # 未达到已掌握（review_stage != 8）
            Question.is_deleted == False
        )
    )

    if course_id:
        query = query.filter(Question.course_id == course_id)

    results = query.limit(limit).all()

    # 分离题目和做错时间，并将 naive datetime 转换为 timezone-aware（UTC）
    questions = []
    wrong_times = {}
    for q, w_time in results:
        questions.append(q)
        # 将 naive datetime 转换为 timezone-aware（UTC）
        if w_time and w_time.tzinfo is None:
            w_time = w_time.replace(tzinfo=timezone.utc)
        wrong_times[q.id] = w_time

    return {
        "questions": questions,
        "wrong_times": wrong_times
    }
```

**关键业务逻辑**（中文注释）：
```python
# 子查询：找出每个题目最近一次答错的记录
# 关键业务逻辑：确保错题本只提取最近一次做错的情况
latest_wrong_subquery = (
    db.query(...)
    .filter(UserAnswerHistory.is_correct == False)
    .group_by(UserAnswerHistory.question_id)
    .subquery()
)

# 主查询：筛选出曾经答错过、且未达到已掌握状态的题目
# 关键业务逻辑：错题本只显示历史错题且未掌握的题目
# 即使中途答对，只要未掌握（review_stage != 8），仍在错题本中
query = (
    db.query(...)
    .filter(UserLearningRecord.review_stage != EbbinghausScheduler.MAX_STAGE)
)
```

#### 修改：`ReviewService.get_next_question()`

**变更说明**：
1. 验证错题推荐逻辑只依赖 `review_stage`，与 `is_correct` 解耦
2. 不需要修改（当前逻辑已经满足需求）

```python
@staticmethod
def get_next_question(
    db: Session,
    user_id: str,
    course_id: Optional[str] = None,
    batch_size: int = 10,
    allow_new_round: bool = True
) -> List[Question]:
    """
    获取下一批复习题目（支持多轮模式）

    优先级（保持不变，已满足需求）：
    1. 需要复习的题目（按照艾宾浩斯曲线）
       - 包括：错题本题目（历史上答错过）和普通复习题
       - 已与 is_correct 解耦，只看 review_stage
    2. 用户没刷过的题
    3. 如果 allow_new_round=True 且没有可用题，开始新轮

    变更说明：
    - 无需修改，当前逻辑已经满足"错题推荐与 is_correct 解耦"的需求
    - 只依赖 review_stage 和 next_review_time
    """
    # ... 现有逻辑保持不变 ...
```

---

### 3. API 变更

#### 修改：`mistakes.py` API

**变更说明**：
1. `last_wrong_time` 字段现在从 `UserAnswerHistory` 表查询
2. API 接口无需改变，但底层逻辑已更新

```python
@router.get("", response_model=List[dict])
def get_wrong_questions(
    user_id: str,
    course_id: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    获取错题列表

    变更说明：
    - last_wrong_time 现在从 UserAnswerHistory 表查询
    - 其他逻辑保持不变
    """
    wrong_data = ReviewService.get_wrong_questions(db, user_id, course_id)
    wrong_questions = wrong_data["questions"]
    wrong_times = wrong_data["wrong_times"]

    # ✅ 不再需要查询 UserLearningRecord 的 answer 字段
    # 因为 last_wrong_time 已经从 UserAnswerHistory 获取

    return [
        {
            "id": q.id,
            "content": q.content,
            # ... 其他字段 ...
            "last_wrong_time": wrong_times.get(q.id),  # ✅ 从历史记录获取
        }
        for q in wrong_questions
    ]
```

---

### 4. 批次服务变更

#### 修改：`QuizService.finish_batch()`

**变更说明**：
1. 调用 `ReviewService.submit_answer()` 时传递 `batch_id`
2. 确保历史记录与批次关联

```python
@staticmethod
def finish_batch(
    db: Session,
    user_id: str,
    batch_id: str
) -> dict:
    """
    完成批次（统一对答案）

    变更说明：
    - 调用 ReviewService.submit_answer() 时传递 batch_id
    - 确保历史记录与批次关联
    """
    # ... 现有逻辑 ...

    # 保存到学习记录（传递 batch_id）
    for answer in answers:
        if answer.user_answer:
            ReviewService.submit_answer(
                db,
                user_id=user_id,
                question_id=answer.question_id,
                answer=answer.user_answer,
                is_correct=answer.is_correct,
                batch_id=batch_id  # ✅ 新增参数
            )

    return {
        "batch_id": batch_id,
        "total": total,
        "correct": correct,
        "wrong": wrong,
        "accuracy": round(correct / total * 100, 2) if total > 0 else 0
    }
```

---

### 5. 数据库迁移

#### 迁移脚本：创建 `UserAnswerHistory` 表

```python
# migration_add_user_answer_history.py

def upgrade():
    op.create_table(
        'user_answer_history',
        sa.Column('id', sa.String(36), primary_key=True),
        sa.Column('user_id', sa.String(36), nullable=False),
        sa.Column('question_id', sa.String(36), nullable=False),
        sa.Column('answer', sa.String(10), nullable=False),
        sa.Column('is_correct', sa.Boolean, nullable=False),
        sa.Column('answered_at', sa.DateTime, nullable=False, server_default=sa.func.current_timestamp()),
        sa.Column('review_stage', sa.Integer, nullable=False),
        sa.Column('batch_id', sa.String(36), nullable=True),
        sa.ForeignKeyConstraint(['user_id'], ['users.id']),
        sa.ForeignKeyConstraint(['question_id'], ['questions.id']),
        sa.Index('idx_user_question', 'user_id', 'question_id'),
        sa.Index('idx_answered_at', 'answered_at'),
        sa.Index('idx_user_id', 'user_id'),
        sa.Index('idx_question_id', 'question_id')
    )

def downgrade():
    op.drop_table('user_answer_history')
```

---

## 风险评估

### 1. 数据一致性

**风险**：
- `UserLearningRecord` 和 `UserAnswerHistory` 可能不一致

**缓解措施**：
- 确保所有答题操作同时写入两张表
- 使用数据库事务保证原子性
- 添加数据校验逻辑

### 2. 性能影响

**风险**：
- `UserAnswerHistory` 表可能快速增长
- 查询性能可能下降

**缓解措施**：
- 添加适当的索引（user_id, question_id, answered_at）
- 避免复杂 JOIN 查询，使用子查询+内存过滤
- 定期归档历史数据（如需）

### 3. 向后兼容

**风险**：
- 现有代码可能依赖 `UserLearningRecord.is_correct`

**缓解措施**：
- 保留 `is_correct` 字段（不删除），但不再使用
- 逐步迁移到新逻辑
- 添加注释标记废弃字段

---

## 测试计划

### 1. 单元测试

**测试场景**：
1. 提交答案后，`UserAnswerHistory` 表创建新记录
2. 多次答题后，`UserAnswerHistory` 包含所有历史记录
3. 错题本查询正确返回最近一次做错的题目
4. 错题推荐逻辑只依赖 `review_stage`

### 2. 集成测试

**测试场景**：
1. 批次刷题完整流程
2. 错题本重做流程
3. 艾宾浩斯复习调度

### 3. 数据验证

**验证点**：
- `UserAnswerHistory` 表记录数 = 总答题次数
- 错题本显示的题目 = 历史上答错过且未掌握的题目
- 轮次管理不受影响

---

## 总结

### 改动点

1. **新增表**：`UserAnswerHistory`（历史答题记录）
2. **废弃字段**：`UserLearningRecord.is_correct`、`UserLearningRecord.answer`、`UserLearningRecord.answered_at`
3. **修改方法**：
   - `ReviewService.submit_answer()` - 创建历史记录
   - `ReviewService.get_wrong_questions()` - 使用历史记录查询
   - `QuizService.finish_batch()` - 传递 batch_id
4. **API 无需变更**：接口保持不变，底层逻辑更新

### 关键要点

1. **历史追踪**：每次答题都创建新记录，永不更新
2. **逻辑解耦**：错题推荐只依赖 `review_stage`
3. **错题本优化**：同一题错多次时，显示最近一次做错
4. **轮次保护**：轮次管理逻辑不受影响
5. **减少冗余**：`UserLearningRecord` 不再存储 answer 和 is_correct

### 预期效果

- ✅ 历史做错的题正确出现在错题本中
- ✅ 错题推荐与 `is_correct` 解耦，只看 `review_stage`
- ✅ 支持题目维度的历史数据分析
- ✅ 轮次管理不受影响
- ✅ 数据冗余减少
