# 批次刷题题目推荐逻辑修复 - 改动日志

**日期**: 2026-01-22
**关联文档**: `change_intent/批次刷题题目推荐逻辑修复.md`

---

## 问题描述

题目刷完后开启批次报错"没有可用的题目"，可能和之前的刷题记录改造有关。

---

## 修复内容

### 1. 题目推荐逻辑修复

**文件**: `src/backend/app/services/review_service.py`

**修复前的问题**：
- 题目推荐只考虑"艾宾浩斯复习题"和"新题"
- 艾宾浩斯复习查询中混入了 `completed_in_current_round` 条件，导致两个独立逻辑耦合
- 轮次切换后，已掌握的题目（`review_stage == 8`）被完全忽略
- 导致第二轮开始时无法获取题目

**修复方案**：
将艾宾浩斯复习逻辑和轮次管理逻辑完全解耦：
- 艾宾浩斯复习逻辑：只看 `review_stage` 和 `next_review_time`
- 轮次管理逻辑：只看 `completed_in_current_round`
- 两个逻辑独立，通过去重来合并结果

**优先级调整**：
1. **优先**：艾宾浩斯复习阶段的题目（`review_stage` 在 1-7 之间，复习时间到了）
2. **次优先**：当前轮次未刷过的题目（包括已掌握的，与复习题去重）
3. **再次**：新题（完全没有学习记录的题目）

**代码变更**：

```python
# 1. 优先：艾宾浩斯复习阶段的题目（只看艾宾浩斯复习条件）
due_query = db.query(Question).join(UserLearningRecord).filter(
    UserLearningRecord.user_id == user_id,
    UserLearningRecord.next_review_time <= now,
    UserLearningRecord.review_stage < EbbinghausScheduler.MAX_STAGE,  # 未掌握（review_stage < 8）
    UserLearningRecord.review_stage > 0,           # 有复习记录（排除新题）
    Question.is_deleted == False
    # 移除了 completed_in_current_round 条件，艾宾浩斯复习逻辑与轮次管理解耦
)

due_questions = due_query.order_by(UserLearningRecord.next_review_time).limit(batch_size).all()

if len(due_questions) >= batch_size:
    return due_questions[:batch_size]

# 2. 次优先：当前轮次未刷过的题目（只看轮次管理条件）
remaining_slots = batch_size - len(due_questions)

# 获取已获取的复习题ID列表，用于去重
due_question_ids = [q.id for q in due_questions]

not_completed_query = db.query(Question).join(UserLearningRecord).filter(
    UserLearningRecord.user_id == user_id,
    UserLearningRecord.completed_in_current_round == False,  # 当前轮次未刷过
    Question.is_deleted == False
)

# 与复习题去重，避免重复返回同一道题
if due_question_ids:
    not_completed_query = not_completed_query.filter(~Question.id.in_(due_question_ids))

not_completed_questions = not_completed_query.limit(remaining_slots).all()
result = due_questions + not_completed_questions

if len(result) >= batch_size:
    return result[:batch_size]

# 3. 再次：新题（保持不变）
remaining_slots = batch_size - len(result)

new_questions_query = db.query(Question).outerjoin(UserLearningRecord).filter(
    or_(
        UserLearningRecord.id == None,
        and_(
            UserLearningRecord.review_stage == 0,
            UserLearningRecord.next_review_time == None
        )
    ),
    Question.is_deleted == False
)

new_questions = new_questions_query.limit(remaining_slots).all()
result = result + new_questions
```

**关键业务逻辑**（添加中文注释）：
- 艾宾浩斯复习逻辑和轮次管理逻辑完全独立，不相互耦合
- 艾宾浩斯复习：只看 `review_stage` 和 `next_review_time`，判断哪些题目需要复习
- 轮次管理：只看 `completed_in_current_round`，判断哪些题目在当前轮次刷过
- 新轮次开始后，所有题目都应该可以重新刷题（`completed_in_current_round` 被重置为 `False`）

---

### 2. "第1批0"显示问题分析

**文件**: `src/frontend/app/courses/page.tsx`

**分析结果**：
- 前端显示逻辑正确
- 初始状态：`current_round = 1`, `total_rounds_completed = 0`
- 显示为"第 1 轮"（当 `total_rounds_completed > 0` 时才显示"已完成 X 轮"）
- 用户描述的"第1批0"可能是表达不准确

**结论**：
- 前端显示逻辑无需修改

---

## 影响范围

### 修改的文件
1. `src/backend/app/services/review_service.py` - 题目获取逻辑

### 修改的影响
- **核心修复**：解决了题目刷完后开启批次报错"没有可用的题目"的问题
- **业务逻辑**：已掌握的题目在新轮次可以重新刷题
- **优先级调整**：复习题 > 已掌握未刷题 > 新题

---

## 验证场景

### 1. 新用户第一次刷题
- **期望**：返回新题（`review_stage == 0`）
- **验证**：✅ 查询1（复习题）和查询2（已掌握未刷题）都返回空，查询3（新题）返回结果

### 2. 第一轮刷完后开启第二轮
- **期望**：返回已掌握但未在新轮刷过的题目（`review_stage == 8 AND completed_in_current_round == False`）
- **验证**：✅ 查询1（复习题）返回空，查询2（已掌握未刷题）返回结果

### 3. 有艾宾浩斯复习题时
- **期望**：优先返回复习题（`review_stage` 在 1-7 之间）
- **验证**：✅ 查询1（复习题）返回结果，不会执行查询2和查询3

### 4. 所有题目都刷完后开启新轮
- **期望**：可以正常开启并获取题目
- **验证**：✅ 新轮逻辑触发，轮次切换后，查询2返回已掌握未刷题

---

## 已知问题

### LSP 类型检查警告
修复过程中触发的 LSP 类型检查警告是 SQLAlchemy 2.0 的已知问题，不是本次修复引入的：

```python
# 这些警告是 SQLAlchemy 2.0 类型系统的限制
Argument of type "Column[int] | Literal[0]" cannot be assigned to parameter "current_stage"
Cannot assign to attribute "review_stage" for class "UserLearningRecord"
```

这些警告不影响代码运行，是因为 SQLAlchemy 的类型系统对 ORM 模型的属性赋值有特殊处理。

---

## 总结

### 核心修复
题目推荐逻辑增加"已掌握但未在新轮次刷过的题目"作为第二优先级，解决了题目刷完后开启批次报错"没有可用的题目"的问题。

### 关键业务逻辑
- 艾宾浩斯复习算法独立于轮次管理
- 轮次切换后，所有题目都应该可以在新轮次重新刷题
- 优先级：复习题 > 已掌握未刷题 > 新题

### 代码注释
所有关键业务逻辑都有中文注释，确保代码可维护性。
