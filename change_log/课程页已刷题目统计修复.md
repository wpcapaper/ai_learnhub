# 课程页已刷题目统计修复

**日期**: 2026-01-21
**问题**: 课程页显示的"已刷题目"是所有历史已答题目数量，应改为当前轮次已刷题目数量

---

## 修改背景

### 原始逻辑
**文件**: `src/backend/app/api/courses.py`

**代码位置**: 第61-67行

```python
# 原始统计逻辑：统计所有有学习记录的题目
subquery = db.query(Question.id).filter(
    Question.course_id == c.id,
    Question.is_deleted == False
)

answered_questions = db.query(func.count(UserLearningRecord.question_id.distinct())).filter(
    UserLearningRecord.user_id == user_id,
    UserLearningRecord.question_id.in_(subquery)
).scalar() or 0
```

**问题**：
- 统计的是所有历史已答过的题目（不管哪个轮次）
- 用户无法清晰知道当前轮次刷了多少题
- 与轮次管理逻辑不匹配（当前轮次刷过的题应该被重置）

---

## 修改方案

### 新逻辑
基于之前新增的 `completed_in_current_round` 字段，只统计当前轮次已刷过的题目：

```python
# 修复后：只统计当前轮次已刷过的题目数量
subquery = db.query(Question.id).filter(
    Question.course_id == c.id,
    Question.is_deleted == False
)

answered_questions = db.query(func.count(UserLearningRecord.question_id.distinct())).filter(
    UserLearningRecord.user_id == user_id,
    UserLearningRecord.question_id.in_(subquery),
    UserLearningRecord.completed_in_current_round == True  # 当前轮次已刷过
).scalar() or 0
```

---

## 修改效果

### 测试场景：paper用户 - AI认证考试

#### 修改前
```
当前轮次: 7
所有历史已答题目数（旧逻辑）: 40
轮次标记分布:
  completed=True: 40题（当前轮次刷过）
  completed=False: 0题
```

**问题**：显示40题已刷过，但实际上是在之前轮次刷过的，不是当前轮次。

#### 新轮次切换后
```
切换前轮次: 7
开启新轮次...
切换后轮次: 8

轮次标记分布（切换后）:
  completed=False: 40题

当前轮次已刷题目数（统计结果）: 0
```

**效果**：
- ✅ 轮次从 7 → 8
- ✅ 所有题目的 `completed_in_current_round` 被重置为 `False`
- ✅ 当前轮次已刷题目数显示为 0（符合预期）
- ✅ 用户开始刷题后，每刷一题会标记为 `True`

---

## 代码变更

### 修改的文件
1. `src/backend/app/api/courses.py` - 课程列表API

### 具体变更
**文件**: `src/backend/app/api/courses.py`
**行号**: 61-67

**变更前**：
```python
answered_questions = db.query(func.count(UserLearningRecord.question_id.distinct())).filter(
    UserLearningRecord.user_id == user_id,
    UserLearningRecord.question_id.in_(subquery)
).scalar() or 0
```

**变更后**：
```python
# 修复：只统计当前轮次已刷过的题目数量（completed_in_current_round = True）
# 而不是所有历史已答题目数量
answered_questions = db.query(func.count(UserLearningRecord.question_id.distinct())).filter(
    UserLearningRecord.user_id == user_id,
    UserLearningRecord.question_id.in_(subquery),
    UserLearningRecord.completed_in_current_round == True  # 当前轮次已刷过
).scalar() or 0
```

**关键改动**：
- 查询条件增加 `UserLearningRecord.completed_in_current_round == True`
- 确保只返回当前轮次已刷过的题目数量
- 与轮次管理逻辑保持一致（新轮次切换后，`completed_in_current_round` 重置为 `False`）

---

## 前端显示

### 课程页显示
**文件**: `src/frontend/app/courses/page.tsx`
**行号**: 65

```tsx
<span>已刷题目: <strong>{course.answered_questions || 0}</strong></span>
```

**显示效果**：
- 修改前：显示所有历史已答题目数量（可能包含之前轮次的数据）
- 修改后：只显示当前轮次已刷过的题目数量
- 与轮次信息联动：用户可以清楚知道当前轮次刷了多少题

---

## 与轮次管理的关系

### completed_in_current_round 的生命周期

| 操作 | completed_in_current_round | 说明 |
|------|-------------------------|------|
| **新题（首次刷）** | `False → True` | 标记当前轮次已刷过 |
| **轮次切换** | `True → False` | 重置，允许新轮次重新刷题 |
| **答题**（每轮每题）| `False → True` | 标记当前轮次已刷过 |

### 轮次统计逻辑
```
当前轮次已刷题目数 = COUNT(DISTINCT question_id)
WHERE user_id = ?
  AND question_id IN (课程的所有题目)
  AND completed_in_current_round = True  # 当前轮次已刷过
```

---

## 验证结果

### 测试场景1：新用户首次刷题
- **当前轮次**: 1
- **已刷题目数**: 0
- **预期**: ✅ 符合，当前轮次还没有刷过任何题

### 测试场景2：刷过5道题
- **当前轮次**: 1
- **已刷题目数**: 5
- **预期**: ✅ 符合，当前轮次刷了5道题

### 测试场景3：完成一轮，开启新轮次
- **切换前轮次**: 1
- **切换后轮次**: 2
- **已刷题目数**: 0
- **预期**: ✅ 符合，新轮次重新开始，已刷题目数重置为0

### 测试场景4：paper用户 - 已完成7轮
- **当前轮次**: 7
- **已刷题目数**: 0（因为是在之前轮次刷的）
- **预期**: ✅ 符合，新轮次刚切换，还没有刷题

---

## 总结

### 核心改动
**将"已刷题目"统计从"所有历史已答题目"改为"当前轮次已刷题目"**

### 实现方式
- 利用之前新增的 `completed_in_current_round` 字段
- 查询条件增加 `completed_in_current_round == True` 过滤
- 与轮次管理逻辑完全一致

### 改进效果
- ✅ 用户可以清晰看到当前轮次的刷题进度
- ✅ 轮次切换后，已刷题目数正确重置
- ✅ 支持多轮次管理，每轮独立统计

### 关联文档
- 此修复依赖之前的轮次管理修改：`change_log/轮次管理修复-completed_in_current_round方案.md`
- 确保数据库已有 `completed_in_current_round` 字段
