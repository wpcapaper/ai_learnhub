# 艾宾浩斯算法优化 - 首次答对直接视为已掌握

**日期**: 2026-01-23
**问题描述**: 原始逻辑没有对首次做对的题做特殊处理，导致首次答对和错题回退都被视为 stage 1，无法区分优先级

---

## 问题根源分析

### 原始逻辑缺陷

**文件**: `src/backend/app/core/ebbinghaus.py`

**原始代码**:
```python
if is_correct:
    next_stage = min(current_stage + 1, cls.MAX_STAGE)  # 8 = MASTERED
else:
    next_stage = 1  # 回到第一阶段
```

**关键问题**：

| 场景 | current_stage | is_correct | next_stage | next_review_time |
|------|---------------|------------|------------|------------------|
| 新题答对 | 0 | ✅ True | 1 | 30分钟后 |
| 新题答错 | 0 | ❌ False | 1 | 30分钟后 |
| 复习题答错 | 3 | ❌ False | 1 | 30分钟后 |

**核心问题**：
1. 新题答对 → `stage 0 → 1`
2. 错题回退 → `stage X → 1`
3. **无法区分这两类题目**

### 实际影响

在 `review_service.py:get_next_question` 中：
```python
due_query = db.query(Question).filter(
    UserLearningRecord.next_review_time <= now,
    UserLearningRecord.review_stage < 8,    # 未掌握
    UserLearningRecord.review_stage > 0,    # 排除 stage 0 的新题
    ...
)
```

这个查询会同时返回：
- ✅ 首次做对的题（stage 0 → 1）
- ❌ 曾经答错的题（stage 3 → 1）

**从数据库层面，这两类题完全无法区分**，导致：
1. 首次答对的题和错题混在一起推荐
2. 无法给错题更高的优先级
3. 违反了艾宾浩斯算法的原始意图（首次答对应该快速通过）

---

## 解决方案

### 核心设计思想

**首次答对直接视为已掌握**

逻辑说明：
- 新题（stage 0）答对 → 直接跳到 stage 8（已掌握）
- 复习题（stage > 0）答对 → 进入下一阶段
- 答错 → 回到 stage 1 重新开始

### 优势分析

| 维度 | 原逻辑 | 新逻辑 |
|------|--------|--------|
| 首次答对处理 | 进入 stage 1（30分钟后复习） | 直接 stage 8（已掌握） |
| 与错题区分 | 无法区分（都是 stage 1） | 明确区分（错题 stage 1，首次答对 stage 8） |
| 复习优先级 | 混合，无法区分 | 错题自然优先（stage 1 vs stage 8） |
| 算法意图 | 不符合 | 符合（快速通过已掌握的知识） |

---

## 代码变更

### 变更文件

**文件**: `src/backend/app/core/ebbinghaus.py`

### 修改后的代码

```python
@classmethod
def calculate_next_review(cls, current_stage: int, is_correct: bool):
    """
    计算下次复习时间

    关键业务逻辑：
    - 首次答对（current_stage == 0 且 is_correct == True）→ 直接视为已掌握（stage 8）
    - 复习题答对（current_stage > 0 且 is_correct == True）→ 进入下一阶段
    - 答错（is_correct == False）→ 回到第1阶段重新开始

    Args:
        current_stage: 当前复习阶段 (0-7)
        is_correct: 是否答对

    Returns:
        tuple: (next_stage, next_review_time or None)
    """
    if is_correct:
        # 关键业务逻辑：首次答对直接视为已掌握
        if current_stage == 0:
            next_stage = cls.MAX_STAGE  # 新题答对 → 直接掌握
        else:
            next_stage = min(current_stage + 1, cls.MAX_STAGE)  # 复习题答对 → 下一阶段
    else:
        next_stage = 1  # 答错 → 回到第1阶段

    if next_stage == cls.MAX_STAGE:
        return next_stage, None  # 已掌握

    interval = cls.REVIEW_INTERVALS[next_stage]
    next_time = datetime.utcnow() + timedelta(minutes=interval)
    return next_stage, next_time
```

### 关键改动说明

#### 1. 增加首次答对判断

```python
if is_correct:
    if current_stage == 0:
        next_stage = cls.MAX_STAGE  # 新题答对 → 直接掌握
    else:
        next_stage = min(current_stage + 1, cls.MAX_STAGE)
```

**关键业务逻辑**：
- 判断当前是否为首次答题（`current_stage == 0`）
- 如果是首次答对，直接跳到 `MAX_STAGE`（stage 8），视为已掌握
- 如果是复习题答对，继续进入下一阶段

#### 2. 保持错题回退逻辑不变

```python
else:
    next_stage = 1  # 答错 → 回到第1阶段
```

**说明**：
- 答错的题目回到 stage 1
- 30分钟后需要重新复习
- 错题优先级自然高于已掌握的题目（stage 8）

---

## 修改后的逻辑流程

### 题目状态转换图

```
新题（stage 0）
    │
    ├─→ 答对 ─────────────────────→ stage 8（已掌握）✨
    │                                    无需复习
    │
    └─→ 答错 ────────────────────→ stage 1（30分钟后）
                                       ↓
                                   [等待30分钟]
                                       ↓
                                   [到期可复习]
                                       ↓
                                   ┌───┴───┐
                                   │       │
                              答对 → stage 2（12小时）
                              答错 → stage 1（重新开始）
                                       ↓
                                  [继续复习流程...]
```

### 场景对比表

| 场景 | current_stage | is_correct | next_stage | next_review_time | 状态 |
|------|---------------|------------|------------|------------------|------|
| 新题答对 | 0 | ✅ True | 8 | None | **已掌握** ✨ |
| 新题答错 | 0 | ❌ False | 1 | 30分钟后 | 错题，需复习 |
| 复习题答错 | 3 | ❌ False | 1 | 30分钟后 | 错题，回退 |
| 复习题答对 | 3 | ✅ True | 4 | 2天后 | 正常复习 |
| 复习题答对 | 7 | ✅ True | 8 | None | 已掌握 |

---

## 验证结果

### 测试场景

#### 场景 1：首次答对

**输入**：
- `current_stage = 0`
- `is_correct = True`

**输出**：
- `next_stage = 8`
- `next_review_time = None`

**验证**：✅ 新题答对直接视为已掌握，无需复习

---

#### 场景 2：首次答错

**输入**：
- `current_stage = 0`
- `is_correct = False`

**输出**：
- `next_stage = 1`
- `next_review_time = 30分钟后`

**验证**：✅ 新题答错回到 stage 1，30分钟后复习

---

#### 场景 3：复习题答错

**输入**：
- `current_stage = 3`
- `is_correct = False`

**输出**：
- `next_stage = 1`
- `next_review_time = 30分钟后`

**验证**：✅ 复习题答错回到 stage 1，重新开始复习周期

---

#### 场景 4：复习题答对

**输入**：
- `current_stage = 3`
- `is_correct = True`

**输出**：
- `next_stage = 4`
- `next_review_time = 2天后`

**验证**：✅ 复习题答对正常进入下一阶段

---

### 优先级验证

在 `review_service.py:get_next_question` 中的查询：

```python
due_query = db.query(Question).filter(
    UserLearningRecord.next_review_time <= now,
    UserLearningRecord.review_stage < 8,    # 排除已掌握（stage 8）
    ...
)
```

**验证**：
- 首次答对的题（stage 8）✅ 不会被查询到（`review_stage < 8` 过滤）
- 错题（stage 1）✅ 会被查询到，且优先级最高（最早复习）
- 复习题（stage 1-7）✅ 按时间排序，自然优先

**结论**：首次答对的题和错题现在可以明确区分，错题优先级自然更高

---

## 影响范围

### 修改的文件

1. `src/backend/app/core/ebbinghaus.py` - 艾宾浩斯算法核心逻辑

### 无需修改的文件

- ✅ `src/backend/app/services/review_service.py` - 复习服务（无需改动）
- ✅ `src/backend/app/services/quiz_service.py` - 刷题服务（无需改动）
- ✅ `src/backend/app/services/exam_service.py` - 考试服务（无需改动）
- ✅ 数据库模型 - 无需新增字段或迁移

### 向后兼容性

**影响分析**：

| 影响项 | 说明 |
|--------|------|
| 新用户 | ✅ 无影响，直接应用新逻辑 |
| 老用户 | ✅ 现有数据兼容，自动应用新逻辑 |
| 已掌握的题 | ✅ 保持已掌握状态（stage 8） |
| 复习中的题 | ✅ 继续按新逻辑推进/回退 |
| 数据库迁移 | ✅ 无需迁移，无模式变更 |

**数据一致性**：
- 现有的 `review_stage = 8` 的记录保持不变
- 现有的 `review_stage = 1-7` 的记录按新逻辑继续
- 无数据迁移风险

---

## 逻辑验证

### 题目推荐优先级

修改后，题目推荐的自然优先级为：

| 优先级 | 题目类型 | review_stage | next_review_time | 说明 |
|--------|---------|---------------|------------------|------|
| 1 | 错题 | 1 | ≤ now | 30分钟后到期，优先级最高 |
| 2 | 复习题 | 2-7 | ≤ now | 按时间排序，早期优先 |
| 3 | 新题 | 0 | None | 首次学习 |
| 4 | 已掌握 | 8 | None | 不会出现在推荐列表 |

**关键改进**：
- ✅ 首次答对的题直接进入 stage 8，与错题明确区分
- ✅ 错题自然获得最高优先级（stage 1）
- ✅ 不需要额外字段或复杂逻辑

---

## 总结

### 核心改进

**首次答对直接视为已掌握**

### 实现方式

1. 在 `calculate_next_review` 中增加首次答题判断
2. 首次答对（`current_stage == 0 且 is_correct == True`）→ 直接跳到 stage 8
3. 错题继续回到 stage 1
4. 复习题正常进入下一阶段

### 解决的问题

- ✅ 首次答对和错题可以明确区分
- ✅ 错题自然获得最高复习优先级
- ✅ 符合艾宾浩斯算法的原始意图（快速通过已掌握的知识）
- ✅ 无需数据库迁移，向后兼容

### 设计优势

- ✅ 逻辑简洁，无需额外字段
- ✅ 优先级自然区分（stage 1 vs stage 8）
- ✅ 向后兼容，无数据迁移风险
- ✅ 符合用户期望（首次做对=已掌握）
